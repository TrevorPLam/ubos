#!/usr/bin/env tsx

/**
 * Generate Repo-Wide Task Index
 * 
 * This script consolidates all task indices from the 30 agent roles
 * into a single repo-wide TASK_INDEX.md file.
 * 
 * Usage: npm run generate-task-index
 */

import { readFileSync, writeFileSync, readdirSync, existsSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const _isMainModule = import.meta.url === `file://${process.argv[1]}`;

interface TaskEntry {
  id: string;
  type: string;
  priority: string;
  component: string;
  status: string;
  location: string;
  created: string;
  completed?: string;
  title: string;
  role: string;
}

interface RoleTasks {
  role: string;
  tasks: TaskEntry[];
}

const AGENTS_DIR = join(process.cwd(), 'agents', 'roles');
const OUTPUT_FILE = join(process.cwd(), 'TASK_INDEX.md');

function parseTaskIndex(content: string, role: string): TaskEntry[] {
  const tasks: TaskEntry[] = [];
  const lines = content.split('\n');
  let currentTask: Partial<TaskEntry> | null = null;
  let inEntry = false;

  for (const line of lines) {
    if (line.trim() === '## index_entry_begin') {
      currentTask = { role };
      inEntry = true;
      continue;
    }

    if (line.trim() === '## index_entry_end') {
      if (currentTask && currentTask.id) {
        tasks.push(currentTask as TaskEntry);
      }
      currentTask = null;
      inEntry = false;
      continue;
    }

    if (!inEntry || !currentTask) continue;

    // Parse task properties
    if (line.startsWith('[id:')) {
      currentTask.id = line.match(/\[id:([^\]]+)\]/)?.[1] || '';
    } else if (line.startsWith('type:')) {
      currentTask.type = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('priority:')) {
      currentTask.priority = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('component:')) {
      currentTask.component = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('status:')) {
      currentTask.status = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('location:')) {
      currentTask.location = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('created:')) {
      currentTask.created = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('completed:')) {
      currentTask.completed = line.split(':')[1]?.trim() || '';
    } else if (line.startsWith('title:')) {
      currentTask.title = line.split(':')[1]?.trim() || '';
    }
  }

  return tasks;
}

function readRoleTaskIndex(role: string): TaskEntry[] {
  const indexPath = join(AGENTS_DIR, role, 'tasks', 'TASK_INDEX.md');
  
  if (!existsSync(indexPath)) {
    console.warn(`Warning: TASK_INDEX.md not found for role: ${role}`);
    return [];
  }

  try {
    const content = readFileSync(indexPath, 'utf-8');
    return parseTaskIndex(content, role);
  } catch (error) {
    console.error(`Error reading task index for role ${role}:`, error);
    return [];
  }
}

function generateMarkdown(roleTasks: RoleTasks[]): string {
  const totalTasks = roleTasks.reduce((sum, rt) => sum + rt.tasks.length, 0);
  const timestamp = new Date().toISOString().split('T')[0];

  // Generate role sections
  const roleSections = roleTasks.map(rt => {
    if (rt.tasks.length === 0) {
      return `### ${rt.role}\n<!-- AUTO-GENERATED: ${rt.role} tasks -->\n\n---\n\n`;
    }

    const taskEntries = rt.tasks.map(task => {
      const completed = task.completed ? `\ncompleted: ${task.completed}` : '';
      return `## index_entry_begin
[id:${task.id}]
type: ${task.type}
priority: ${task.priority}
component: ${task.component}
status: ${task.status}
location: ${task.location}
created: ${task.created}${completed}
title: ${task.title}
role: ${task.role}
## index_entry_end`;
    }).join('\n\n');

    return `### ${rt.role}
<!-- AUTO-GENERATED: ${rt.role} tasks -->

${taskEntries}

---

`;
  }).join('');

  // Generate statistics
  const stats = generateStatistics(roleTasks);

  return `# REPO-WIDE TASK INDEX

<!--
SYSTEM INSTRUCTIONS ‚Äî TASK_INDEX.md (repo-wide)

Purpose: Central registry consolidating all tasks across 30 agent roles.

Source of truth: Individual role task indices in /agents/roles/*/tasks/TASK_INDEX.md

Rules:
1) This file is AUTO-GENERATED by script/generate-task-index.ts
2) Do NOT edit manually - run the generation script instead
3) Entries are grouped by role for clarity
4) Each entry includes: task ID, type, priority, component, status, location, created date, title, and owning role
5) Entries are sorted by role name, then chronologically by creation date
6) Status values: todo | in-progress | blocked | done
7) Location values: BACKLOG.md | TODO.md | ARCHIVE.md (relative to role's tasks/ directory)
-->

## üìä Repository Task Overview

**Total Roles:** ${roleTasks.length}  
**Total Tasks:** ${totalTasks}  
**Last Generated:** ${timestamp}  
**Generation Command:** \`npm run generate-task-index\`

---

## üóÇ Tasks by Role

${roleSections}

## üìà Summary Statistics

${stats}

---

## üîç Task Search & Filtering

To find specific tasks:

1. **By ID**: Search \`[id:TASK-YYYYMMDD-NNN]\`
2. **By Type**: Search \`type:security\`, \`type:config\`, etc.
3. **By Priority**: Search \`priority:critical\`, \`priority:high\`, etc.
4. **By Status**: Search \`status:todo\`, \`status:in-progress\`, etc.
5. **By Component**: Search \`component:server\`, \`component:client\`, etc.

---

## üîÑ Regeneration

To update this index:

\`\`\`bash
npm run generate-task-index
\`\`\`

This script:
- Scans all 30 role directories
- Parses individual TASK_INDEX.md files
- Consolidates into this repo-wide view
- Updates timestamp and statistics
`;
}

function generateStatistics(roleTasks: RoleTasks[]): string {
  const allTasks = roleTasks.flatMap(rt => rt.tasks);
  
  // Count by status
  const statusCounts = allTasks.reduce((acc, task) => {
    acc[task.status] = (acc[task.status] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Count by priority
  const priorityCounts = allTasks.reduce((acc, task) => {
    acc[task.priority] = (acc[task.priority] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Count by type
  const typeCounts = allTasks.reduce((acc, task) => {
    acc[task.type] = (acc[task.type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Roles with active tasks
  const rolesWithTasks = roleTasks.filter(rt => rt.tasks.length > 0).length;

  const stats = [];

  stats.push(`**Total Tasks:** ${allTasks.length}`);
  stats.push(`**Roles with Tasks:** ${rolesWithTasks}/${roleTasks.length}`);
  
  stats.push('\n**By Status:**');
  Object.entries(statusCounts).forEach(([status, count]) => {
    stats.push(`- ${status}: ${count}`);
  });

  stats.push('\n**By Priority:**');
  Object.entries(priorityCounts).forEach(([priority, count]) => {
    stats.push(`- ${priority}: ${count}`);
  });

  stats.push('\n**By Type (Top 10):**');
  Object.entries(typeCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10)
    .forEach(([type, count]) => {
      stats.push(`- ${type}: ${count}`);
    });

  return stats.join('\n');
}

function main() {
  console.log('üîç Scanning agent roles for task indices...');
  console.log(`üìÅ AGENTS_DIR: ${AGENTS_DIR}`);

  // Get all role directories
  const roles = readdirSync(AGENTS_DIR, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name)
    .sort();

  console.log(`üìÅ Found ${roles.length} roles: ${roles.slice(0, 5).join(', ')}${roles.length > 5 ? '...' : ''}`);

  // Read task indices from all roles
  const roleTasks: RoleTasks[] = roles.map(role => {
    const tasks = readRoleTaskIndex(role);
    console.log(`üìã ${role}: ${tasks.length} tasks`);
    return { role, tasks };
  });

  const totalTasks = roleTasks.reduce((sum, rt) => sum + rt.tasks.length, 0);
  console.log(`üìä Total tasks found: ${totalTasks}`);

  // Generate consolidated index
  console.log('üìù Generating consolidated task index...');
  const markdown = generateMarkdown(roleTasks);

  // Write to output file
  writeFileSync(OUTPUT_FILE, markdown, 'utf-8');
  
  console.log(`‚úÖ Generated TASK_INDEX.md with ${totalTasks} tasks from ${roles.length} roles`);
}

// Force execution for debugging
main();
