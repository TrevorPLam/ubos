# ADR Pattern (Architecture Decision Records)\n\n**Official**: https://adr.github.io/  \n**Creator**: Michael Nygard (2011)  \n**Purpose**: Lightweight documentation of architectural decisions  \n**When to Use**: Documenting why significant architectural choices were made\n\n---\n\n## üìù What is an ADR?\n\n**Definition**: A short text file in Markdown that records a significant architectural decision and the context and consequences of that decision.\n\n**Why ADRs?**\n- Preserve the **why**, not just the **what**\n- Help future developers understand decisions\n- Provide a decision trail for auditing\n- Make reversing decisions easier\n- Enable better discussions about tradeoffs\n\n**When to use ADRs**:\n- Choosing between significant alternatives\n- Making decisions that are hard to reverse\n- Deciding on technology or architecture\n- Establishing standards or patterns\n\n---\n\n## üìã ADR Template\n\n### Minimal Template (Recommended for UBOS)\n\n```markdown\n# ADR-[number]: [Title]\n\nDate: YYYY-MM-DD\nStatus: [Proposed | Accepted | Deprecated | Superseded by ADR-X]\nAuthors: [Who made this decision]\nReviewers: [Who reviewed it]\n\n## Context\n\n[What problem are we solving? What's the background?]\n[Why is this decision important right now?]\n\n## Problem Statement\n\n[The specific issue we're addressing]\n[Constraints we're working with]\n\n## Options Considered\n\n### Option A: [Name]\nPros:\n- \n\nCons:\n-\n\n### Option B: [Name]\nPros:\n-\n\nCons:\n-\n\n### Option C: [Name]\nPros:\n-\n\nCons:\n-\n\n## Decision\n\nWe will [use/implement/do this].\n\n## Rationale\n\n[Why we chose this option. What tradeoffs are we accepting?]\n\n## Consequences\n\n### Positive\n- We gain [benefit]\n- This enables [capability]\n\n### Negative\n- We accept [risk/limitation]\n- This requires [additional work]\n\n## Alternative Outcomes\n\nIf [condition], we would reconsider this decision.\n\n## Related Decisions\n\n- ADR-X: [Related decision]\n- ADR-Y: [Related decision]\n```\n\n---\n\n## üìö UBOS ADR Examples\n\n### Example 1: Modular Monolith Architecture\n\n```markdown\n# ADR-001: Use Modular Monolith Architecture\n\nDate: 2025-01-15\nStatus: Accepted\nAuthors: Architecture Team\nReviewers: Engineering Lead, CTO\n\n## Context\n\nUBOS is a SaaS platform for business operations. We need to decide on \nour architectural approach: monolithic, microservices, or something in between.\n\nFactor: We want to move fast early on, but need to scale later.\nFactor: We have a small team (8 engineers), not 50.\nFactor: We need clear data isolation for multi-tenancy.\n\n## Problem Statement\n\nMonolithic apps are easy to build but hard to scale. Microservices \nscale well but are complex to build and operate, especially for small teams.\n\n## Options Considered\n\n### Option A: Traditional Monolith\nPros:\n- Single deployment\n- Simple data model\n- Easy to develop\n\nCons:\n- Hard to scale\n- Technology locked-in\n- Team coordination issues at scale\n\n### Option B: Microservices\nPros:\n- Independent scaling\n- Technology flexibility\n- Team autonomy\n\nCons:\n- Operational complexity\n- Distributed debugging\n- Network latency\n- Overkill for small team\n\n### Option C: Modular Monolith (Chosen)\nPros:\n- Single deployment (easier operations)\n- Technology consistency\n- Organized code (domain-driven design)\n- Easy to split to microservices later\n\nCons:\n- Still have monolith deployment overhead\n- Requires discipline to maintain boundaries\n\n## Decision\n\nWe will use a modular monolith architecture with the following characteristics:\n- Single Node.js/Express server\n- Domain-organized modules (CRM, Workflow, Revenue, etc.)\n- Clear module boundaries with dependency rules\n- Prepared for eventual migration to microservices\n\n## Rationale\n\nThe modular monolith gives us the best tradeoff for our current situation:\n1. Easy to build and deploy (monolith benefits)\n2. Well-organized code (microservices benefits)\n3. Can migrate individual modules to services later\n4. Matches our team size (small, high-trust)\n\n## Consequences\n\n### Positive\n- Fast development cycle\n- Single source of truth for deployment\n- Clear domain boundaries\n- Can scale individual domains later without rebuilding\n\n### Negative\n- Must enforce module boundaries strictly (no cheating)\n- Database locks might become bottleneck (premature scaling issue)\n- Requires up-front design of module interfaces\n\n## Alternative Outcomes\n\nIf we reach 50+ engineers or need true independent scaling for specific \ndomains, we would split CRM (heavy traffic) into a separate service.\n\n## Related Decisions\n\n- ADR-002: Single PostgreSQL Database\n- ADR-003: Express.js as API Framework\n```\n\n---\n\n### Example 2: Multi-Tenant Data Isolation\n\n```markdown\n# ADR-005: Row-Level Security for Multi-Tenant Isolation\n\nDate: 2025-02-01\nStatus: Accepted\nAuthors: Security Team, Database Team\nReviewers: CTO, Product Manager\n\n## Context\n\nUBOS serves multiple customers (tenants) from a single database. \nWe must ensure customer data never leaks across tenant boundaries.\n\nOptions: Separate databases, separate schemas, or row-level security.\n\n## Problem Statement\n\nHow do we ensure multi-tenant isolation while maintaining operational simplicity?\n\n## Options Considered\n\n### Option A: Separate Database Per Tenant\nPros:\n- Guaranteed isolation\n- Easy to implement (no code changes)\n\nCons:\n- Operational nightmare (managing 1000+ databases)\n- Expensive (1000+ database instances)\n- Hard to maintain (1000+ schema migrations)\n\n### Option B: Separate Schema Per Tenant\nPros:\n- Still simple isolation\n- Better operational efficiency\n\nCons:\n- Still many schemas to manage\n- Hard to query across tenants\n- Expensive (many schema copies)\n\n### Option C: Row-Level Security (Chosen)\nPros:\n- Single schema, single database\n- Query-level isolation (automatic)\n- Efficient for operations\n- Cost-effective\n\nCons:\n- Must implement carefully\n- Performance impact (small)\n- Requires discipline in queries\n\n## Decision\n\nWe will use PostgreSQL Row-Level Security (RLS) with:\n- Single database\n- Single tenant_id column on all tables\n- RLS policies preventing cross-tenant queries\n- Application-level tenant context validation\n\n## Rationale\n\nRLS provides database-level enforcement of isolation, so even bugs \nin the application layer won't leak data. It's also cost-effective and\noperationally simple for our small team.\n\n## Consequences\n\n### Positive\n- Defense in depth (app + database isolation)\n- Single simple database to maintain\n- Lowest operational overhead\n- Easiest to implement initially\n\n### Negative\n- Small performance impact (RLS policy evaluation)\n- Requires careful implementation\n- Must disable RLS in migration scripts\n- New developers must understand RLS\n\n## Alternative Outcomes\n\nIf we find RLS isn't isolating properly or causes issues, we would \nfall back to schema-per-tenant approach.\n\n## Related Decisions\n\n- ADR-001: Modular Monolith (enables single database)\n- ADR-004: PostgreSQL Database Choice\n```\n\n---\n\n## üéØ ADR Best Practices\n\n### Content\n\n**DO**:\n- ‚úÖ Keep it concise (1-2 pages max)\n- ‚úÖ Document the context and constraints\n- ‚úÖ Explain all options considered\n- ‚úÖ State the decision clearly\n- ‚úÖ Explain the rationale (the \"why\")\n- ‚úÖ Document consequences (positive and negative)\n- ‚úÖ Date it\n- ‚úÖ Mark the status (Proposed, Accepted, Deprecated, Superseded)\n\n**DON'T**:\n- ‚ùå Make it a novel (be concise)\n- ‚ùå Skip alternatives (show you considered options)\n- ‚ùå Make decisions without context (explain the problem first)\n- ‚ùå Ignore negative consequences (acknowledge tradeoffs)\n- ‚ùå Make it too technical (explain for future developers)\n\n### Naming\n\n```\nADR-[number]: [Concise title]\n\n‚úÖ ADR-001: Use Modular Monolith Architecture\n‚úÖ ADR-005: PostgreSQL Row-Level Security for Isolation\n‚úÖ ADR-010: React for Frontend Framework\n\n‚ùå ADR-001: Architecture\n‚ùå ADR-001: Technology Decisions\n‚ùå ADR-001: Meeting Notes on Architecture\n```\n\n### Numbering\n\n- Use sequential numbers (001, 002, 003...)\n- Never reuse numbers\n- Don't be afraid to have gaps (ADR-005 skips to ADR-010)\n- Good prefix: ADR-00[n] for single digit, ADR-0[nn] for double\n\n### Status\n\n**Proposed**\n- New decision being discussed\n- Not yet approved\n- Marked for review\n\n**Accepted**\n- Approved and implemented\n- Team is committed\n- Guides future decisions\n\n**Deprecated**\n- No longer recommended\n- Replaced but still in use (for reference)\n- Point to replacement decision\n\n**Superseded by ADR-X**\n- Replaced by newer decision\n- Keep for historical context\n- Note what changed and why\n\n---\n\n## üìÇ UBOS ADR Structure\n\n```\ndocs/\n‚îî‚îÄ‚îÄ adr/\n    ‚îú‚îÄ‚îÄ README.md (ADR index)\n    ‚îú‚îÄ‚îÄ ADR-001-modular-monolith.md\n    ‚îú‚îÄ‚îÄ ADR-002-postgresql-database.md\n    ‚îú‚îÄ‚îÄ ADR-003-express-api.md\n    ‚îú‚îÄ‚îÄ ADR-004-react-frontend.md\n    ‚îú‚îÄ‚îÄ ADR-005-row-level-security.md\n    ‚îú‚îÄ‚îÄ ADR-006-typescript-language.md\n    ‚îú‚îÄ‚îÄ ADR-007-drizzle-orm.md\n    ‚îú‚îÄ‚îÄ ADR-008-multi-tenant-from-start.md\n    ‚îú‚îÄ‚îÄ ADR-009-jwt-sessions.md\n    ‚îú‚îÄ‚îÄ ADR-010-environment-configuration.md\n    ‚îî‚îÄ‚îÄ ...\n```\n\n### ADR Index File\n\n```markdown\n# Architecture Decision Records\n\n## All Decisions\n\n| # | Title | Status | Date |\n|---|-------|--------|------|\n| [001](ADR-001-modular-monolith.md) | Use Modular Monolith | Accepted | 2025-01-15 |\n| [002](ADR-002-postgresql.md) | PostgreSQL Database | Accepted | 2025-01-15 |\n| [003](ADR-003-express.md) | Express.js API | Accepted | 2025-01-15 |\n| ... | ... | ... | ... |\n\n## By Category\n\n### Architecture\n- [ADR-001: Modular Monolith](ADR-001-modular-monolith.md)\n- [ADR-002: PostgreSQL](ADR-002-postgresql.md)\n\n### Technology\n- [ADR-003: Express.js](ADR-003-express.md)\n- [ADR-004: React](ADR-004-react.md)\n\n### Security\n- [ADR-005: Row-Level Security](ADR-005-rls.md)\n- [ADR-009: JWT Sessions](ADR-009-jwt.md)\n```\n\n---\n\n## ‚úÖ Quality Checklist\n\n### Before Proposing an ADR\n- [ ] Is this decision significant enough to document?\n- [ ] Have we discussed alternatives?\n- [ ] Have we documented the context?\n- [ ] Have we explained the consequences?\n- [ ] Is it concise (1-2 pages max)?\n- [ ] Would a developer 2 years from now understand this?\n\n### Before Accepting an ADR\n- [ ] All stakeholders have reviewed\n- [ ] Tradeoffs are clearly explained\n- [ ] Consequences (positive and negative) are listed\n- [ ] Related decisions are referenced\n- [ ] No obvious alternatives were skipped\n\n### When Superseding an ADR\n- [ ] Old ADR marked as \"Superseded by ADR-X\"\n- [ ] New ADR explains what changed and why\n- [ ] Migration plan is documented (if needed)\n- [ ] Old ADR is kept for historical context\n\n---\n\n## üîÑ ADR Lifecycle\n\n```\n1. Propose\n   ‚îî‚îÄ‚Üí ADR created, status = \"Proposed\"\n       Team discusses, provides feedback\n\n2. Refine\n   ‚îî‚îÄ‚Üí Update based on feedback\n       Address concerns\n       Document alternatives\n\n3. Accept\n   ‚îî‚îÄ‚Üí Status changed to \"Accepted\"\n       Decision is made and committed\n\n4. Implement\n   ‚îî‚îÄ‚Üí Architecture is implemented\n       Code follows the decision\n       Documentation updated\n\n5. Maintain\n   ‚îî‚îÄ‚Üí Monitor consequences\n       Revisit if conditions change\n       Consider deprecating if needed\n\n6. Supersede (Optional)\n   ‚îî‚îÄ‚Üí Status = \"Superseded by ADR-X\"\n       Keep for historical reference\n       Point to new decision\n```\n\n---\n\n## üîó Related Standards\n\n- **ISO 42010**: ADRs fit in the \"Rationale Viewpoint\"\n- **C4 Model**: ADRs document why architecture looks like diagrams\n- **Di√°taxis Framework**: ADRs are \"Explanation\" mode documentation\n\n---\n\n## üìö Tools & Resources\n\n### ADR Tools\n1. **adr-tools**: Command-line tool to manage ADRs\n   ```bash\n   adr new \"Use PostgreSQL\"\n   adr list\n   adr log\n   ```\n\n2. **Plain Markdown**: Just use git + markdown (simplest)\n\n3. **ADR GitHub Template**: Pre-made template for GitHub\n\n### Reading Material\n- **Official ADR Site**: https://adr.github.io/\n- **Michael Nygard's Original Post**: https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions\n- **ADR Examples**: https://github.com/adr/adr-examples\n\n---\n\n## üöÄ Getting Started with UBOS\n\n### Phase 1: Backfill (Now)\n1. Create ADRs for existing major decisions\n2. Document the 5-10 most important choices\n3. Date them as \"2025-01\"\n\n### Phase 2: Going Forward\n1. Create new ADR for any significant decision\n2. Include in pull request reviews\n3. Reference in documentation\n4. Review quarterly\n\n### Immediate Actions\n1. Create docs/adr/ folder\n2. Write ADR template\n3. Document ADR-001 through ADR-010 (existing decisions)\n4. Add ADR index\n5. Link from architecture docs\n\n---\n\n## üí° UBOS-Specific Guidance\n\n### Good Candidates for ADRs\n- Technology choices (Express, React, PostgreSQL)\n- Architectural patterns (modular monolith, multi-tenant)\n- Security decisions (RLS, encryption, session management)\n- Data modeling choices (schemas, migrations)\n- Integration approaches (third-party APIs, webhooks)\n\n### Not Good for ADRs\n- Minor implementation details\n- Bug fixes\n- Performance optimizations\n- Code style choices (use style guides instead)\n\n---\n\n**Last Updated**: 2026-02-04  \n**Review Cycle**: With each major decision  \n**Tool**: Plain Markdown in docs/adr/  \n**Format**: ADR-[number]-[kebab-case].md\n"